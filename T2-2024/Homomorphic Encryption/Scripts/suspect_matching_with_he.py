# -*- coding: utf-8 -*-
"""Suspect Matching With HE_3.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1TK675IXOYWfVhR-WRc5KToKR-I28FqHo
"""

# Install required packages
!pip install Pyfhel
!pip install faker

# Import libraries
import pandas as pd
import numpy as np
import hashlib
from faker import Faker
import random
from datetime import datetime, timedelta
import uuid
from Pyfhel import Pyfhel, PyCtxt

# Setup faker for data generation
fake = Faker()

# Function to create realistic customer data
def create_person_data(num_people, shared_ids=[]):
    data = []
    for _ in range(num_people):
        person_id = np.random.randint(1000000, 9999999)
        if shared_ids:
            person_id = shared_ids.pop(0)
        person = {
            "Name": fake.name(),
            "DOB": fake.date_of_birth(minimum_age=16, maximum_age=120),
            "ID": person_id,
            "Address": fake.address(),
            "Country": fake.country()
        }
        data.append(person)
    return pd.DataFrame(data)

# Function to create suspect data with some shared IDs
def create_suspect_data(num_suspects, shared_ids):
    data = []
    num_shared = int(0.1 * num_suspects)  # 10% of suspects should have matching IDs
    for i in range(num_suspects):
        if i < num_shared:
            person_id = shared_ids[i]
        else:
            person_id = np.random.randint(1000000, 9999999)
        person = {
            "Name": fake.name(),
            "DOB": fake.date_of_birth(minimum_age=16, maximum_age=120),
            "ID": person_id,
            "Address": fake.address(),
            "Country": fake.country()
        }
        data.append(person)
    return pd.DataFrame(data)

# Function to create fraud data
def create_fraud_data(num_entries):
    data = []
    for _ in range(num_entries):
        entry = {
            "Time": fake.date_time_between(start_date='-1y', end_date='now').strftime('%H:%M:%S'),
            "Date": fake.date_time_between(start_date='-1y', end_date='now').strftime('%Y-%m-%d'),
            "Sender_account": np.random.randint(1, 10000000000, dtype=np.int64),
            "Receiver_account": np.random.randint(1, 10000000000, dtype=np.int64),
            "Amount": fake.random_number(digits=random.randint(1, 6)),
            "Payment_currency": fake.currency_code(),
            "Received_currency": fake.currency_code(),
            "Sender_bank_location": fake.country(),
            "Receiver_bank_location": fake.country(),
            "Payment_type": fake.random_element(['Credit card', 'Debit card', 'Cheque', 'ACH', 'Cross-border', 'Cash Withdrawal', 'Cash Deposit']),
            "Is_laundering": np.random.choice([0, 1], p=[0.99, 0.01]),
            "Laundering_type": fake.random_element(['Normal_Small_Fan_Out', 'Normal_Fan_Out', 'Normal_Fan_In', 'Normal_Group', 'Normal_Cash_Withdrawal', 'Normal_Cash_Deposits',
                                                    'Normal_Periodical', 'Normal_Plus_Mutual', 'Normal_Mutual', 'Normal_Foward', 'Normal_single_large', 'Structuring',
                                                    'Cash_Withdrawal', 'Deposit-Send', 'Smurfing', 'Layered_Fan_In', 'Layered_Fan_Out', 'Stacked Bipartite', 'Behavioural_Change_1',
                                                    'Bipartite', 'Cycle', 'Fan_In', 'Gather-Scatter', 'Behavioural_Change_2', 'Scatter-Gather', 'Single_large', 'Fan_Out', 'Over-Invoicing'])
        }
        data.append(entry)
    return pd.DataFrame(data)

# Function to generate transaction list
def generate_transaction_list(num_transactions):
    transaction_list = []
    current_date = datetime.now()
    start_balance = random.randint(0, 50000)
    balance = start_balance

    for _ in range(num_transactions):
        transaction_id = str(uuid.uuid4())
        transaction_date = current_date.strftime("%d-%m-%Y")
        transaction_type = random.choice(["credit", "debit"])

        if transaction_type == "credit":
            credit_amt = random.randint(100, 4000)
            debit_amt = 0
            balance += credit_amt
        else:
            credit_amt = 0
            debit_amt = random.randint(100, 4000)
            balance -= debit_amt

        transaction = {
            "transaction_id": transaction_id,
            "date": transaction_date,
            "transaction_type": transaction_type,
            "credit_amt": credit_amt,
            "debit_amt": debit_amt,
            "balance": balance
        }
        transaction_list.append(transaction)

        days_to_add = random.randint(1, 7)
        current_date += timedelta(days=days_to_add)

    return pd.DataFrame(transaction_list)

# Initialize Pyfhel for homomorphic encryption
HE = Pyfhel()
HE.contextGen(scheme='bfv', n=2**14, t=65537)
HE.keyGen()

# Plain text matching for individual
def match_plain(tar, sus):
    int1 = np.array([tar], dtype=np.int64)
    int2 = np.array([sus], dtype=np.int64)
    resSub = int1 - int2
    if (resSub) == [0]:
        return f"Person ID {tar} has matched to suspect ID: {sus}"

# Hash matching for individual
def match_hash(tar, sus):
    tar = str(tar)
    sus = str(sus)
    ec1 = tar.encode()
    ec2 = sus.encode()
    hash1 = hashlib.sha256(ec1).hexdigest()
    hash2 = hashlib.sha256(ec2).hexdigest()
    if hash1 == hash2:
        return f"Person ID {tar} has matched to suspect ID: {sus}"

# Homomorphic encryption matching for individual
def match_HE(tar, sus):
    int1 = np.array([tar], dtype=np.int64)
    int2 = np.array([sus], dtype=np.int64)

    ctxt1 = HE.encryptInt(int1)
    ctxt2 = HE.encryptInt(int2)

    ctxtSub = ctxt1 - ctxt2
    resSub = HE.decryptInt(ctxtSub)

    if resSub[0] == 0:
        return f"Person ID {tar} has matched to suspect ID: {sus}"

# Plain text matching for list
def listmatch_plain(tar, sus):
    matches = []
    for l in range(len(sus)):
        for t in range(len(tar)):
            match_res = match_plain(tar[t], sus[l])
            if match_res:
                matches.append(match_res)
    return matches

# Hash matching for list
def listmatch_hash(tar, sus):
    matches = []
    for l in range(len(sus)):
        for t in range(len(tar)):
            match_res = match_hash(tar[t], sus[l])
            if match_res:
                matches.append(match_res)
    return matches

# Homomorphic encryption matching for list
def listmatch_HE(tar, sus):
    matches = []
    for l in range(len(sus)):
        for t in range(len(tar)):
            match_res = match_HE(tar[t], sus[l])
            if match_res:
                matches.append(match_res)
    return matches

# Generate sample data
num_people = 100
num_suspects = 10

# Generate shared IDs to ensure 10% matches
shared_ids = [np.random.randint(1000000, 9999999) for _ in range(int(0.1 * num_suspects))]

# Create customer and suspect data with shared IDs
customer_data = create_person_data(num_people, shared_ids.copy())
suspect_data = create_suspect_data(num_suspects, shared_ids)

# Convert data to lists for matching
customer_ids = customer_data['ID'].to_list()
suspect_ids = suspect_data['ID'].to_list()

# Perform plain text matching
plain_matches = listmatch_plain(customer_ids, suspect_ids)
print("Plain Text Matches:")
print(plain_matches)

# Perform hash matching
hash_matches = listmatch_hash(customer_ids, suspect_ids)
print("Hash Matches:")
print(hash_matches)

# Perform homomorphic encryption matching
HE_matches = listmatch_HE(customer_ids, suspect_ids)
print("Homomorphic Encryption Matches:")
print(HE_matches)